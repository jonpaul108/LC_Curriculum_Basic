<h1>sver-compat</h1>
<p><a href="https://travis-ci.org/phated/sver-compat"><img src="https://travis-ci.org/phated/sver-compat.svg?branch=master" alt="Build Status"></a></p>
<p>Fork of @guybedford's <a href="https://github.com/guybedford/sver">Sver</a> library. Adds compatibility for node &lt;6.</p>
<pre><code>npm install sver-compat
</code></pre>
<pre><code class="language-js">var Semver = require('sver-compat').Semver;
var SemverRange = require('sver-compat').SemverRange;

// Static usage:
SemverRange.match('^1.2.3', '1.2.4'); // true

// Class usage:
var range = new SemverRange('^1.2.3');
var version = new Semver('1.2.4');
version.matches(range);               // true
range.has(version);                   // true
</code></pre>
<h3>Range support</h3>
<p>Restricts version ranges to the simplified cases:</p>
<ul>
<li><code>*</code>: Wildcard range</li>
<li><code>MAJOR</code>: Match exact major</li>
<li><code>MAJOR.MINOR</code> Match exact major and minor</li>
<li><code>MAJOR.MINOR.PATCH[-PRE]</code> Match exact semver</li>
<li><code>~MAJOR.MINOR.PATCH[-PRE]</code>: Match patch bumps</li>
<li><code>^MAJOR.MINOR.PATCH[-PRE]</code>: Match minor and patch bumps</li>
</ul>
<p>Invalid ranges will fallback to being detected as exact string matches.</p>
<h3>Prerelease Matching</h3>
<p>By default, as per convention, ranges like <code>^1.2.3-alpha</code> only match prerelease ranges on the same patch (<code>1.2.3-alpha.4</code>), but
not prerelease ranges from further patches (<code>1.3.4-alpha</code>).</p>
<p>To alter this matching, a third boolean argument can be provided to the match function to support these unstable matches:</p>
<pre><code class="language-js">SemverRange.match('^1.2.3', '1.5.6-beta');       // false
SemverRange.match('^1.2.3', '1.5.6-beta', true); // true
</code></pre>
<h3>Best Version Match</h3>
<pre><code class="language-js">var versions = ['1.2.3', '1.3.4-alpha', '1.3.4-alpha.1', '1.3.4-beta'];
var range = new SemverRange('*');

var bestStableMatch = range.bestMatch(versions);
bestStableMatch.toString();                     // 1.2.3

var bestUnstableMatch = range.bestMatch(versions, true);
bestUnstableMatch.toString();                   // 1.3.4-beta
</code></pre>
<h3>Version and Range Sorting</h3>
<pre><code class="language-js">var versions = ['2.4.5', '2.3.4-alpha', '1.2.3', '2.3.4-alpha.2'];
var ranges = ['^1.2.3', '1.2', '2.3.4'];

versions.sort(Semver.compare);   // [1.2.3, 2.3.4-alpha, 2.3.4-alpha.2, 2.4.5]
ranges.sort(SemverRange.compare) // [1.2, ^1.2.3, 2.3.4]
</code></pre>
<h3>Conversion from Node Semver Ranges</h3>
<p>A utility function is included to convert Node Semver ranges into Semver ranges.</p>
<p>This requires <code>semver</code> to be installed in the application running this process.</p>
<p><em>Note this conversion is lossy by definition.</em></p>
<pre><code class="language-js">var convertRange = require('sver-compat/convert-range');

convertRange('&gt;=2.3.4 &lt;3.0.0').toString(); // ^2.3.4
convertRange('1 || 2 || 3').toString();    // ^3.0.0
</code></pre>
<h3>Semver and Semver Range Validation</h3>
<p>When a version string fails semver validation it falls back to being treated as a tag, still as a <code>Semver</code> instance.</p>
<p>For example:</p>
<pre><code class="language-js">var version = new Semver('x.y.z');
version.tag === 'x.y.z';             // true

version = new Semver('^1.2.3');
version.major === undefined;         // true
version.tag === '^1.2.3';            // true
</code></pre>
<p>For validation, rather use <code>Semver.isValid</code> and <code>SemverRange.isValid</code>:</p>
<pre><code class="language-js">Semver.isValid('x.y.z');             // false
Semver.isValid('^1.2.3');            // false
SemverRange.isValid('^1.2.3');       // true
</code></pre>
<h2>API</h2>
<h3>Semver</h3>
<p>Static methods:</p>
<ul>
<li><code>Semver.isValid(version: string): boolean</code>: Whether the given string is a valid semver.</li>
<li><code>Semver.compare(v1: Semver|string, v2: Semver|string): number</code>: 1 if v1 &gt; v2, -1 if v1 &lt; v2, 0 if equal.</li>
</ul>
<p>For a given Semver instance <code>version = new Semver('X.Y.Z')</code>,</p>
<ul>
<li><code>version.major</code>: The major version number.</li>
<li><code>version.minor</code>: The minor version number.</li>
<li><code>version.patch</code>: The patch version number.</li>
<li><code>version.pre</code>: The prerelease identifer, as an array of strings (<code>.</code>-separated).</li>
<li><code>version.build</code>: The build identifier, as a string.</li>
<li><code>version.tag</code>: If not a valid semver, the full tag string.</li>
<li><code>version.gt(otherVersion: Semver|string): bool</code>: Whether this version is greater than the other version.</li>
<li><code>version.lt(otherVersion: Semver|string): bool</code>: Whether this version is less than the other version.</li>
<li><code>version.eq(otherVerion: Semver|string): bool</code>: Whether this version equals the other version.</li>
<li><code>version.matches(range: SemverRange|string, unstable?: bool): bool</code>: Whether this version matches the given version range.</li>
<li><code>version.toString(): string</code>: Convert the version back to a string.</li>
</ul>
<h3>SemverRange</h3>
<p>Static methods:</p>
<ul>
<li><code>SemverRange.match(range: SemverRange|string, version: Semver|string, unstable = false): bool</code>: Whether the version matches the range.</li>
<li><code>SemverRange.isValid(range: string): bool</code>: Whether the given range string is a valid semver range (in this simplified grammar).</li>
<li><code>SemverRange.compare(r1: SemverRange|string, r2: SemverRange|string): number</code>: 1 if r1 &gt; r2, -1 if r1 &lt; r2, 0 if equal.</li>
</ul>
<p>For a given SemverRange instance <code>range = new SemverRange('^X.Y.Z')</code>,</p>
<ul>
<li><code>range.type: string</code>: Returns <code>'wildcard'</code>, <code>'major'</code>, <code>'stable'</code> or <code>'exact'</code>.</li>
<li><code>range.version: Smever</code>: Returns the <code>Semver</code> instance corresponding to the range.</li>
<li><code>range.isExact: string</code>: Returns true if the range is an exact version only.</li>
<li><code>range.isStable: string</code>: Returns true if the range is a stable version range.</li>
<li><code>range.isMajor: string</code>: Returns true if the range is a major version range.</li>
<li><code>range.isWildcard: string</code>: Returns true if the range is the wildcard version range.</li>
<li><code>range.gt(otherRange: SemverRange|string): bool</code>: Whether the range is greater than the other range.</li>
<li><code>range.lt(otherRange: SemverRange|string): bool</code>: Whether the range is less than the other range.</li>
<li><code>range.eq(otherRange: SemverRange|string): bool</code>: Whether the range is exactly the same as the other range.</li>
<li><code>range.has(version: Semver|string, unstable = false): bool</code>: Whether the range includes the given version.</li>
<li><code>range.contains(otherRange: SemverRange|string): bool</code>: Whether the range fully contains the other range.</li>
<li><code>range.intersect(otherRange: SemverRange|string): SemverRange|undefined</code>: The intersection range, if any.</li>
<li><code>range.bestMatch(versions: (Semver|string)[], unstable = false): Semver|undefined</code>: The intersection range, if any.</li>
<li><code>range.toString()</code>: Convert the range back to a string.</li>
</ul>
<h2>License</h2>
<p>MIT</p>
