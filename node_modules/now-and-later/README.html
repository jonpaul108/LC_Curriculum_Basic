<p>&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;http://gulpjs.com&quot;&gt;
&lt;img height=&quot;257&quot; width=&quot;114&quot; src=&quot;https://raw.githubusercontent.com/gulpjs/artwork/master/gulp-2x.png&quot;&gt;
&lt;/a&gt;
&lt;/p&gt;</p>
<h1>now-and-later</h1>
<p><a href="https://www.npmjs.com/package/now-and-later"><img src="http://img.shields.io/npm/v/now-and-later.svg" alt="NPM version"></a> <a href="https://www.npmjs.com/package/now-and-later"><img src="http://img.shields.io/npm/dm/now-and-later.svg" alt="Downloads"></a> <a href="https://travis-ci.org/gulpjs/now-and-later"><img src="http://img.shields.io/travis/gulpjs/now-and-later.svg?label=travis-ci" alt="Build Status"></a> <a href="https://ci.appveyor.com/project/gulpjs/now-and-later"><img src="https://img.shields.io/appveyor/ci/gulpjs/now-and-later.svg?label=appveyor" alt="AppVeyor Build Status"></a> <a href="https://coveralls.io/r/gulpjs/now-and-later"><img src="http://img.shields.io/coveralls/gulpjs/now-and-later/master.svg" alt="Coveralls Status"></a> <a href="https://gitter.im/gulpjs/gulp"><img src="https://badges.gitter.im/gulpjs/gulp.svg" alt="Gitter chat"></a></p>
<p>Map over an array or object of values in parallel or series, passing each through the async iterator, with optional lifecycle hooks.</p>
<h2>Usage</h2>
<pre><code class="language-js">var nal = require('now-and-later');

function iterator(value, key, cb){
  // called with each value in sequence
  // also passes the key
  cb(null, value * 2)
}

function create(value, key){
  // called at the beginning of every iteration
  // return a storage object to be passed to each lifecycle method
  return { key: key, value: value };
}

function before(storage){
  // called before the iterator function of every iteration
  // receives the storage returned from `create`
}

function after(result, storage){
  // called after a success occurs in the iterator function of any iteration
  // receives the `result` of the iterator and the storage returned from `create`
}

function error(error, storage){
  // called after an error occurs in the iterator function of any iteration
  // receives the `error` of the iterator and the storage returned from `create`
}

function done(error, results) {
  // called after all iterations complete or an error occurs in an iterator
  // receives an `error` if one occurred and all results (or partial results upon error) of the iterators
}

/*
  Calling mapSeries with an object can't guarantee order
  It uses Object.keys to get an order
  It is better to use an array if order must be guaranteed
 */
nal.mapSeries([1, 2, 3], iterator, {
  create: create,
  before: before,
  after: after,
  error: error
}, done);

nal.map({
  iter1: 1,
  iter2: 2
}, iterator, {
  create: create,
  before: before,
  after: after,
  error: error
}, done);
</code></pre>
<h2>API</h2>
<h3><code>map(values, iterator[, extensions][, callback])</code></h3>
<p>Takes an object or array of <code>values</code> and an <code>iterator</code> function to execute with each value.
Optionally, takes an <code>extensions</code> object and a <code>callback</code> function that is called upon completion of the iterations.</p>
<p>All iterations run in parallel.</p>
<h4><code>values</code></h4>
<p>An array or object of values to iterate over.</p>
<p>If <code>values</code> is an array, iterations are started in order by index. If <code>values</code> is an object, iterations are started in order by the order returned by <code>Object.keys</code> (order is not guaranteed).</p>
<p>If <code>values</code> is an array, the results of each iteration will be mapped to an array. If <code>values</code> is an object, the results of each iteration will be mapped to an object with corresponding keys.</p>
<h4><code>iterator(value, key, done)</code></h4>
<p>An async function called per iteration. All iterations are run in parallel.</p>
<p>The <code>iterator</code> function is called once with each <code>value</code>, <code>key</code> and a function (<code>done(error, result)</code>) to call when the async work is complete.</p>
<p>If <code>done</code> is passed an error as the first argument, the iteration will fail and the sequence will be ended; however, any iterations in progress will still complete. If <code>done</code> is passed a <code>result</code> value as the second argument, it will be added to the final results array or object.</p>
<h4><code>extensions</code></h4>
<p>The <code>extensions</code> object is used for specifying functions that give insight into the lifecycle of each iteration. The possible extension points are <code>create</code>, <code>before</code>, <code>after</code> and <code>error</code>. If an extension point is not specified, it defaults to a no-op function.</p>
<h5><code>extensions.create(value, key)</code></h5>
<p>Called at the very beginning of each iteration with the <code>value</code> being iterated and the <code>key</code> from the array or object. If <code>create</code> returns a value (<code>storage</code>), it is passed to the <code>before</code>, <code>after</code> and <code>error</code> extension points.</p>
<p>If a value is not returned, an empty object is used as <code>storage</code> for each other extension point.</p>
<p>This is useful for tracking information across an iteration.</p>
<h5><code>extensions.before(storage)</code></h5>
<p>Called immediately before each iteration with the <code>storage</code> value returned from the <code>create</code> extension point.</p>
<h5><code>extensions.after(result, storage)</code></h5>
<p>Called immediately after each iteration with the <code>result</code> of the iteration and the <code>storage</code> value returned from the <code>create</code> extension point.</p>
<h5><code>extensions.error(error, storage)</code></h5>
<p>Called immediately after a failed iteration with the <code>error</code> of the iteration and the <code>storage</code> value returned from the <code>create</code> extension point.</p>
<h4><code>callback(error, results)</code></h4>
<p>A function that is called after all iterations have completed or one iteration has errored.</p>
<p>If all iterations completed successfully, the <code>error</code> argument will be empty and the <code>results</code> will be a mapping of the <code>iterator</code> results.</p>
<p>If an iteration errored, the <code>error</code> argument will be passed from that iteration and the <code>results</code> will be whatever partial results had completed successfully before the error occurred.</p>
<h3><code>mapSeries(values, iterator[, extensions][, callback])</code></h3>
<p>Takes an object or array of <code>values</code> and an <code>iterator</code> function to execute with each value.
Optionally, takes an <code>extensions</code> object and a <code>callback</code> function that is called upon completion of the iterations.</p>
<p>All iterations run in serial.</p>
<h4><code>values</code></h4>
<p>An array or object of values to iterate over.</p>
<p>If <code>values</code> is an array, iterations are started in order by index. If <code>values</code> is an object, iterations are started in order by the order returned by <code>Object.keys</code> (order is not guaranteed).</p>
<p>If <code>values</code> is an array, the results of each iteration will be mapped to an array. If <code>values</code> is an object, the results of each iteration will be mapped to an object with corresponding keys.</p>
<h4><code>iterator(value, key, done)</code></h4>
<p>An async function called per iteration. All iterations are run in serial.</p>
<p>The <code>iterator</code> function is called once with each <code>value</code>, <code>key</code> and a function (<code>done(error, result)</code>) to call when the async work is complete.</p>
<p>If <code>done</code> is passed an error as the first argument, the iteration will fail and the sequence will be ended without executing any more iterations. If <code>done</code> is passed a <code>result</code> value as the second argument, it will be added to the final results array or object.</p>
<h4><code>extensions</code></h4>
<p>The <code>extensions</code> object is used for specifying functions that give insight into the lifecycle of each iteration. The possible extension points are <code>create</code>, <code>before</code>, <code>after</code> and <code>error</code>. If an extension point is not specified, it defaults to a no-op function.</p>
<h5><code>extensions.create(value, key)</code></h5>
<p>Called at the very beginning of each iteration with the <code>value</code> being iterated and the <code>key</code> from the array or object. If <code>create</code> returns a value (<code>storage</code>), it is passed to the <code>before</code>, <code>after</code> and <code>error</code> extension points.</p>
<p>If a value is not returned, an empty object is used as <code>storage</code> for each other extension point.</p>
<p>This is useful for tracking information across an iteration.</p>
<h5><code>extensions.before(storage)</code></h5>
<p>Called immediately before each iteration with the <code>storage</code> value returned from the <code>create</code> extension point.</p>
<h5><code>extensions.after(result, storage)</code></h5>
<p>Called immediately after each iteration with the <code>result</code> of the iteration and the <code>storage</code> value returned from the <code>create</code> extension point.</p>
<h5><code>extensions.error(error, storage)</code></h5>
<p>Called immediately after a failed iteration with the <code>error</code> of the iteration and the <code>storage</code> value returned from the <code>create</code> extension point.</p>
<h4><code>callback(error, results)</code></h4>
<p>A function that is called after all iterations have completed or one iteration has errored.</p>
<p>If all iterations completed successfully, the <code>error</code> argument will be empty and the <code>results</code> will be a mapping of the <code>iterator</code> results.</p>
<p>If an iteration errored, the <code>error</code> argument will be passed from that iteration and the <code>results</code> will be whatever partial results had completed successfully before the error occurred.</p>
<h2>License</h2>
<p>MIT</p>
