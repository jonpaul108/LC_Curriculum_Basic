<h1>stream-exhaust</h1>
<p>Ensure that the provided stream is flowing data, even if the stream hasn't been
piped to another stream.</p>
<pre><code class="language-javascript">var exhaustively = require('stream-exhaust');

exhaustively(fs.createReadStream(__filename))
  .on('close', () =&gt; { console.log('all done, despite being streams{1+N}!') });
</code></pre>
<h2>Prior Art</h2>
<p>This is based on <a href="https://github.com/aroneous/stream-consume">stream-consume</a>
by <a href="https://github.com/aroneous">aroneous</a>. It is a separate package because it has
different semantics:</p>
<ol>
<li>It does not call <code>.resume()</code> on streams2+ streams. streams2 streams monkeypatch <code>.pipe</code>
when entering flowing mode; avoiding <code>resume()</code> avoids that fate.</li>
<li>It does not examine <code>._readableState</code>; instead it checks for the presence of <code>._read</code>.</li>
</ol>
<h2>API</h2>
<h3>exhaust(Stream s) -&gt; Stream s</h3>
<p>Takes a stream, <code>s</code>, and returns it. Ensures that the stream is flowing, either by calling
<code>.resume()</code> if the stream is a streams1 stream, or by piping it to a &quot;black hole&quot; stream that
continually asks for more data.</p>
<h2>License</h2>
<p>MIT</p>
