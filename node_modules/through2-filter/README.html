<h1>through2-filter</h1>
<p><a href="https://nodei.co/npm/through2-filter/"><img src="https://nodei.co/npm/through2-filter.png" alt="NPM"></a></p>
<p>This is a super thin wrapper around <a href="http://npm.im/through2">through2</a> that works like <code>Array.prototype.filter</code> but for streams.</p>
<p>For when through2 is just too verbose :wink:</p>
<p>Note you will <strong>NOT</strong> be able to alter the content of the chunks. This is intended for filtering only. If you want to modify the stream content, use either <code>through2</code> or <code>through2-map</code>.</p>
<pre><code class="language-js">var filter = require(&quot;through2-filter&quot;)

var skip = filter(function (chunk) {
  // skip buffers longer than 100
  return chunk.length &lt; 100
})

// vs. with through2:
var skip = through2(function (chunk, encoding, callback) {
  // skip buffers longer than 100
  if (chunk.length &lt; 100) this.push(chunk)
  return callback()
})

// Then use your filter:
source.pipe(skip).pipe(sink)

// Additionally accepts `wantStrings` argument to conver buffers into strings
var alphanum = new RegExp(&quot;^[A-Za-z0-1]+$&quot;)
var scrub = filter({wantStrings: true}, function (str) {
  return alphanum.exec(str)
})

// Works like `Array.prototype.filter` meaning you can specify a function that
// takes up to two* arguments: fn(element, index)
var skip10 = filter(function (element, index) {
  return index &gt; 10
})
</code></pre>
<p>*Differences from <code>Array.prototype.filter</code>:</p>
<ul>
<li>No third <code>array</code> callback argument. That would require realizing the entire stream, which is generally counter-productive to stream operations.</li>
<li><code>Array.prototype.filter</code> doesn't modify the source Array, which is somewhat nonsensical when applied to streams.</li>
</ul>
<h2>API</h2>
<h2><code>require(&quot;through2-filter&quot;)([options], fn)</code></h2>
<p>Create a <code>through2-filter</code> instance that will call <code>fn(chunk)</code>. If <code>fn(chunk)</code> returns &quot;true&quot; the chunk will be passed downstream. Otherwise it will be dropped.</p>
<h2><code>require(&quot;through2-filter&quot;).ctor([options], fn)</code></h2>
<p>Create a <code>through2-filter</code> Type that can be instantiated via <code>new Type()</code> or <code>Type()</code> to create reusable spies.</p>
<h2><code>require(&quot;through2-filter&quot;).obj([options], fn)</code></h2>
<p>Create a <code>through2-filter</code> that defaults to <code>objectMode = true</code>.</p>
<h2><code>require(&quot;through2-filter&quot;).objCtor([options], fn)</code></h2>
<p>Create a <code>through2-filter</code> Type that defaults to <code>objectMode = true</code>.</p>
<h2>Options</h2>
<ul>
<li>wantStrings: Automatically call chunk.toString() for the super lazy.</li>
<li>all other through2 options</li>
</ul>
<h1>LICENSE</h1>
<p>MIT</p>
